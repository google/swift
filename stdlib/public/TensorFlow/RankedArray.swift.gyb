//===-- RankedArray.swift.gyb ---------------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
//
// Dynamically shaped but statically ranked n-dimensional arrays.
//
// Ranked arrays (Array1D, Array2D, etc) use an array of integers to represent a
// shape with known rank. The number of dimensions is guaranteed to equal the
// rank of the array.
//
//===----------------------------------------------------------------------===//

// TODO:
// - Further gyb similar methods of ArrayXD and ArraySliceXD.
// - Add documentation and standardize with ShapedArray.

import CTensorFlow

public typealias Array1D = Array
public typealias ArraySlice1D = ArraySlice

fileprivate extension Array1D {
  /// Creates an Array1D from a ShapedArray.
  /// - Precondition: The ShapedArray must have rank 1.
  /// - Note: This is an internal initializer and should not be exposed to
  ///   users.
  init(base: ShapedArray<Element>) {
    assert(base.rank == 1, "The ShapedArray does not have rank 1.")
    switch base.buffer.allocation {
    case let .native(box):
      self = box.array
    case .tensorFlow:
      self = base.scalars
    }
  }
}

internal extension Array1D where Element : AccelerableByTensorFlow {
  @_versioned
  init(owning cTensor: CTensor) {
    let shape = (0..<TF_NumDims(cTensor)).map { Int(TF_Dim(cTensor, $0)) }
    precondition(shape.count == 1, "The shape does not have 1 dimension.")
    let startAddress = TF_TensorData(cTensor)
      .assumingMemoryBound(to: Element.self)
    let bufferPointer = UnsafeMutableBufferPointer(
      start: startAddress, count: shape.reduce(1, *)
    )
    self = Array(bufferPointer)
  }
}

fileprivate extension ArraySlice1D {
  /// Creates an ArraySlice1D from a ShapedArraySlice.
  /// - Precondition: The ShapedArraySlice must have rank 1.
  /// - Note: This is an internal initializer and should not be exposed to
  ///   users.
  init(base: ShapedArraySlice<Element>) {
    assert(base.rank == 1, "The ShapedArraySlice does not have rank 1.")
    self = base.withUnsafeBufferPointer(ArraySlice.init)
  }
}

internal extension ArraySlice1D where Element : AccelerableByTensorFlow {
  @_versioned
  init(owning cTensor: CTensor) {
    let shape = (0..<TF_NumDims(cTensor)).map { Int(TF_Dim(cTensor, $0)) }
    precondition(shape.count == 1, "Rank is not 1")
    let startAddress = TF_TensorData(cTensor)
      .assumingMemoryBound(to: Element.self)
    let bufferPointer = UnsafeMutableBufferPointer(
      start: startAddress, count: shape.reduce(1, *)
    )
    self = ArraySlice(bufferPointer)
  }
}

%{
  ranks = [2, 3, 4]

  def rankName(rank):
    if rank == 2:
      return 'two'
    elif rank == 3:
      return 'three'
    elif rank == 4:
      return 'four'

  def _elementArrayLiteral(rank):
    return 'Scalar' if rank == 1 else '[' + _elementArrayLiteral(rank - 1) + ']'

  def _element(rank):
    return 'Scalar' if rank == 1 else 'ArraySlice{}D'.format(rank - 1)
}%

% for rank in ranks:
%   elementRank = rank - 1
%   liftedRank = rank + 1
%   ArrayXD = 'Array{}D'.format(rank)
%   TensorXD = 'Tensor{}D'.format(rank)
%   Element = _element(rank)
%   SliceXD = 'ArraySlice{}D'.format(rank)
%   elementArrayLiteral = _elementArrayLiteral(rank)
%   arrayLiteral = '[' + elementArrayLiteral + ']'

/// A ${rankName(rank)}-dimensional array.
public struct ${ArrayXD}<Scalar> {
  /// The underlying ShapedArray of the ${ArrayXD}.
  @_versioned
  internal var base: ShapedArray<Scalar>

  /// The dimensions of the ${ArrayXD}.
  public var shape: [Int] {
    return base.shape
  }

  public static var rank: Int {
    return ${rank}
  }

  public var rank: Int {
    return ${ArrayXD}.rank
  }

  public var scalarCount: Int {
    return base.scalarCount
  }

  public var scalars: [Scalar] {
    get {
      return base.scalars
    }
    set {
      precondition(newValue.count == scalarCount, "Scalar count mismatch.")
      base.scalars = newValue
    }
  }

  /// Creates an ${ArrayXD} from a TensorBuffer and a shape.
  fileprivate init(buffer: TensorBuffer<Scalar>, shape: [Int]) {
    self.init(base: ShapedArray(buffer: buffer, shape: shape))
  }

  /// Creates an ${ArrayXD} from a ShapedArray.
  /// - Note: This is an internal initializer and should not be exposed to
  ///   users.
  @_versioned
  internal init(base: ShapedArray<Scalar>) {
    self.base = base
  }

  /// Creates an ${ArrayXD} from a ShapedArray. Returns nil if the ShapedArray
  /// does not have rank ${rank}.
  public init?(_ other: ShapedArray<Scalar>) {
    guard other.rank == ${rank} else { return nil }
    self.init(base: other)
  }

  /// Creates an ${ArrayXD} from a ShapedArray.
  /// - Precondition: The ShapedArray must have rank ${rank}.
  public init(identicallyRanked other: ShapedArray<Scalar>) {
    precondition(other.rank == ${rank}, "Rank is not ${rank}.")
    self.init(base: other)
  }
}

public extension ${ArrayXD} {
  /// Returns the number of element arrays in an ${ArrayXD} (equivalent to the
  /// first dimension).
  /// - Note: `count` is distinct from `scalarCount`, which represents the total
  ///   number of scalars.
  var count: Int {
    return base.count
  }

  /// Creates an ${ArrayXD} with the specified shape and contiguous scalars in
  /// row-major order.
  /// - Precondition: The number of scalars must equal the product of the
  ///   dimensions of the shape.
  init(shape: [Int], scalars: [Scalar]) {
    precondition(shape.count == ${rank},
                 "The shape does not have ${rank} dimensions.")
    precondition(shape.reduce(1, *) == scalars.count, "Scalar count mismatch.")
    // self = ArraySlice(scalars)
    self.init(base: ShapedArray(shape: shape, scalars: scalars))
  }

  /// Creates an ${ArrayXD} with the specified shape and a single, repeated
  /// value.
  /// - Parameters:
  ///   - shape: The dimensions of the array.
  ///   - repeatedValue: The scalar value to repeat.
  init(shape: [Int], repeating repeatedValue: Scalar) {
    self.init(base: ShapedArray(shape: shape, repeating: repeatedValue))
  }
}

internal extension ${ArrayXD} where Scalar : AccelerableByTensorFlow {
  @_versioned
  init(owning cTensor: CTensor) {
    let shape = (0..<TF_NumDims(cTensor)).map { Int(TF_Dim(cTensor, $0)) }
    let buffer = TensorBuffer<Scalar>(owning: cTensor, count: shape.count)
    self.init(buffer: buffer, shape: shape)
  }
}

public extension ${ArrayXD} {
  func withUnsafeBufferPointer<Result>(
    _ body: (UnsafeBufferPointer<Scalar>) throws -> Result
  ) rethrows -> Result {
    return try base.withUnsafeBufferPointer(body)
  }

  mutating func withUnsafeMutableBufferPointer<Result>(
    _ body: (inout UnsafeMutableBufferPointer<Scalar>) throws -> Result
  ) rethrows -> Result {
    return try base.withUnsafeMutableBufferPointer(body)
  }
}

extension ${ArrayXD} : RandomAccessCollection, MutableCollection {
  public typealias Index = Int
  public typealias Element = ${Element}<Scalar>
  public typealias SubSequence = ${SliceXD}<Scalar>

  public var indices: CountableRange<Int> {
    return base.indices
  }

  public var startIndex: Int {
    return base.startIndex
  }

  public var endIndex: Int {
    return base.endIndex
  }

  /// Access the element ${Element} specified by an index in the leading
  /// dimension.
  /// - Parameter index: Index of the element ${Element}.
  public subscript(index: Int) -> Element {
    get {
      precondition(index < endIndex, "${ArrayXD} index is out of range")
      precondition(index >= startIndex,
                   "${ArrayXD} index is out of range (before startIndex)")
      let slice = ShapedArraySlice<Scalar>(
        base: base,
        baseIndices: [index]
      )
% if rank == 2:
      return slice.withUnsafeBufferPointer(ArraySlice.init)
% else:
      return ${Element}(base: slice)
% end
    }
    set {
      precondition(index < endIndex, "${ArrayXD} index is out of range")
      precondition(index >= startIndex,
                   "${ArrayXD} index is out of range (before startIndex)")
% if rank == 2:
      precondition(shape.dropFirst().elementsEqual([newValue.count]),
                   "Element shape mismatch")
      base[index].scalars = Array(newValue)
% else:
      precondition(shape.dropFirst().elementsEqual(newValue.shape),
                   "Element shape mismatch")
      base[index] = newValue.base
% end
    }
  }

  /// Access the ${SliceXD} specified by a contiguous range of indices.
  /// - Parameter bounds: Contiguous range of indices.
  public subscript(bounds: Range<Int>) -> SubSequence {
    get {
      precondition(
        indices ~= bounds.lowerBound && indices ~= bounds.upperBound - 1,
        "${ArrayXD} indices are out of range")
      return ${SliceXD}(
        base: ShapedArraySlice(
          base: base,
          bounds: CountableRange(bounds)
        )
      )
    }
    set {
      precondition(
        indices ~= bounds.lowerBound && indices ~= bounds.upperBound - 1,
        "${ArrayXD} indices are out of range")
      let subArrayShape = [bounds.count] + shape.dropFirst()
      precondition(subArrayShape == newValue.shape,
                   "Subarray shape mismatch.")
      base[bounds] = newValue.base
    }
  }
}

/// ${TensorXD} conversion
public extension ${ArrayXD} where Scalar : AccelerableByTensorFlow {
  init(_ other: ${TensorXD}<Scalar>) {
    self = other.array
  }
}

/// Equatable conformance
extension ${ArrayXD} : Equatable where Scalar : Equatable {
  static public func == (lhs: ${ArrayXD}, rhs: ${ArrayXD}) -> Bool {
    return lhs.base == rhs.base
  }
}

/// String conversion
extension ${ArrayXD} : CustomStringConvertible {
  /// A textual representation of this ${ArrayXD}.
  public var description: String {
    return base.description
  }
}

public struct ${SliceXD}<Scalar>  {
  /// The underlying ShapedArraySlice of the ${SliceXD}.
  fileprivate var base: ShapedArraySlice<Scalar>

  /// Creates an ${SliceXD} from a ShapedArraySlice.
  /// - Note: This is an internal initializer and should not be exposed to
  ///   users.
  fileprivate init(base: ShapedArraySlice<Scalar>) {
    self.base = base
  }
}

public extension ${SliceXD} {
  var rank: Int {
    return ${rank}
  }

  var shape: [Int] {
    return base.shape
  }

  var scalarCount: Int {
    return base.scalarCount
  }

  var scalars: [Scalar] {
    get {
      return base.scalars
    }
    set {
      precondition(newValue.count == scalarCount, "Scalar count mismatch.")
      base.scalars = newValue
    }
  }
}

/// Slice initializers
public extension ${SliceXD} {
  /// Returns the number of element arrays in an ${SliceXD} (equivalent to the
  /// first dimension).
  /// - Note: `count` is distinct from `scalarCount`, which represents the total
  ///   number of scalars.
  var count: Int {
    return base.count
  }

  /// Creates an ${SliceXD} with the specified shape and contiguous scalars in
  /// row-major order.
  /// - Precondition: The number of scalars must equal the product of the
  ///   dimensions of the shape.
  init(shape: [Int], scalars: [Scalar]) {
    self.init(base: ShapedArraySlice(shape: shape, scalars: scalars))
  }

  /// Creates an ${SliceXD} with the specified shape and a single, repeated value.
  /// - Parameters:
  ///   - shape: The dimensions of the array.
  ///   - repeatedValue: The scalar value to repeat.
  init(shape: [Int], repeating repeatedValue: Scalar) {
    self.init(base: ShapedArraySlice(shape: shape, repeating: repeatedValue))
  }
}

public extension ${SliceXD} {
  func withUnsafeBufferPointer<Result>(
    _ body: (UnsafeBufferPointer<Scalar>) throws -> Result
  ) rethrows -> Result {
    return try base.withUnsafeBufferPointer(body)
  }

  mutating func withUnsafeMutableBufferPointer<Result>(
    _ body: (inout UnsafeMutableBufferPointer<Scalar>) throws -> Result
  ) rethrows -> Result {
    return try base.withUnsafeMutableBufferPointer(body)
  }
}

extension ${SliceXD} : RandomAccessCollection, MutableCollection {
  public typealias Index = Int
  public typealias Element = ${Element}<Scalar>
  public typealias SubSequence = ${SliceXD}

  public var indices: CountableRange<Int> {
    return base.indices
  }

  public var startIndex: Int {
    return base.startIndex
  }

  public var endIndex: Int {
    return base.endIndex
  }

  /// Access the element ${Element} specified by an index in the leading
  /// dimension.
  /// - Parameter index: Index of the element ${Element}.
  public subscript(index: Int) -> Element {
    get {
      precondition(index < endIndex, "${SliceXD} index is out of range")
      precondition(index >= startIndex,
                   "${SliceXD} index is out of range (before startIndex)")
      let slice = ShapedArraySlice<Scalar>(
        base: base.base,
        baseIndices: base.baseIndices + [index],
        bounds: base.bounds
      )
% if rank == 2:
      return slice.withUnsafeBufferPointer(ArraySlice.init)
% else:
      return ${Element}(base: slice)
% end
    }
    set {
      precondition(index < endIndex, "${SliceXD} index is out of range")
      precondition(index >= startIndex,
                   "${SliceXD} index is out of range (before startIndex)")
% if rank == 2:
      precondition(shape.dropFirst().elementsEqual([newValue.count]),
                   "Element shape mismatch")
      base[index] = ShapedArraySlice(shape: [newValue.count], scalars: newValue)
% else:
      precondition(shape.dropFirst().elementsEqual(newValue.shape),
                   "Element shape mismatch")
      base[index] = newValue.base
% end
    }
  }

  /// Access the ${SliceXD} specified by a contiguous range of indices.
  /// - Parameter bounds: Contiguous range of indices.
  public subscript(bounds: Range<Int>) -> SubSequence {
    get {
      precondition(
        indices ~= bounds.lowerBound && indices ~= bounds.upperBound - 1,
        "${SliceXD} indices are out of range")
      return ${SliceXD}(
        base: ShapedArraySlice(
          base: base.base,
          baseIndices: base.baseIndices,
          bounds: CountableRange(bounds)
        )
      )
    }
    set {
      precondition(
        indices ~= bounds.lowerBound && indices ~= bounds.upperBound - 1,
        "${SliceXD} indices are out of range")
      let subArrayShape = [bounds.count] + shape.dropFirst()
      precondition(subArrayShape == newValue.shape, "Subarray shape mismatch")
      base[bounds] = newValue.base
    }
  }
}

/// ${TensorXD} conversion
public extension ${SliceXD} where Scalar : AccelerableByTensorFlow {
  init(_ other: ${TensorXD}<Scalar>) {
    self.init(base: ShapedArraySlice<Scalar>(other.base))
  }
}

/// Equatable conformance
extension ${SliceXD} : Equatable where Scalar : Equatable {
  public static func == (lhs: ${SliceXD}, rhs: ${SliceXD}) -> Bool {
    return lhs.base == rhs.base
  }
}

/// String conversion
extension ${SliceXD} : CustomStringConvertible {
  /// A textual representation of this ${SliceXD}.
  public var description: String {
    return base.description
  }
}
% end
