// RUN: %target-sil-opt -tf-partition %s -o /dev/null
// RUN: %target-sil-opt -tf-partition %s -o /dev/null | %FileCheck %s

import Builtin
import Swift
import TensorFlow

sil [noinline] @__tf_init_scalar : $@convention(thin) <τ_0_0 where τ_0_0 : AccelerableTensorUnit> (@in τ_0_0) -> @owned TensorHandle<τ_0_0>

// Test that a single constant can be partitioned out, the most basic
// case possible.

// CHECK-LABEL: -- TFPartition Accelerator Result: simple_test
// CHECK: bb0:
// CHECK-NEXT: %0 = float_literal $Builtin.FPIEEE32, 0x3F800000 // 1
// CHECK-NEXT: %1 = builtin "__tfop_Const__cd:t__"(%0 : $Builtin.FPIEEE32) : $TensorHandle<Float>
// CHECK-NEXT: return %1 : $TensorHandle<Float>
// CHECK-NEXT: }

// CHECK-LABEL: --- TFPartition Host Result: simple_test
// CHECK-NOT: = apply
// CHECK: [[STARTFN:%.*]] = function_ref @_swift_tfc_StartTensorComputation
// CHECK-NEXT: [[PROGRAM:%.*]] = apply [[STARTFN:%.*]]
// CHECK-NOT: = apply
// CHECK: [[FINISHFN:%.*]] = function_ref @_swift_tfc_FinishTensorComputation
// CHECK-NEXT: apply [[FINISHFN]]([[PROGRAM]]

sil @simple_test : $@convention(thin) () -> TensorHandle<Swift.Float> {
bb0:
  %0 = float_literal $Builtin.FPIEEE32, 0x3F800000 // 1.0
  %1 = struct $Swift.Float (%0 : $Builtin.FPIEEE32)

  %2 = alloc_stack $Float
  store %1 to [trivial] %2 : $*Float
  %4 = function_ref @__tf_init_scalar : $@convention(thin) <τ_0_0 where τ_0_0 : AccelerableTensorUnit> (@in τ_0_0) -> @owned TensorHandle<τ_0_0> // users: %11, %5
  %5 = apply %4<Float>(%2) : $@convention(thin) <τ_0_0 where τ_0_0 : AccelerableTensorUnit> (@in τ_0_0) -> @owned TensorHandle<τ_0_0>
  dealloc_stack %2 : $*Float

  return %5 : $TensorHandle<Swift.Float>
}

